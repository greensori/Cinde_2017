#getting maximum / minimum pulse

#define sumStep 3

int maxPulse[2];
int minPulse[2];
int equalPulse[3] = {0, 0, 0, 0, 0};

#when proc charconverter, must setting both stepPulse and remainPulse/


void initial() {

minPulse[0] = stepPulse[0];
maxPulse[0] = stepPulse[0];

 for (i = 0; i < sumStep; i++) {
  if (maxpulse[0] < stepPulse[i]) {
    maxPulse[2] = {stepPulse[i], i};
  } else if (minPulse[0] > stepPulse[i]) {
    minPulse[2] = {stepPulse[i], i};
  }else if (minPulse[0] = stepPulse[i]) {
    equalPulse[0] = stepPulse[i];
    equalPulse[1] += 1;
    wqualPulse[2] = i;
  }
}

void setPulse(int a, int b) { 
# delay minimum step and pulse
# e.g int a = minPulse[0], int b = minPulse[1]

    digitalWrite(STEP[b], HIGH);
    delayMicroseconds(remainPulse[a]);

  for (i = 0; i < sumStep; i++) {
    remainPulse[i] -= stepPulse[i];
    if (remainPulse[i] < stepPulse[i]) {
      remainPulse[i] = stepPulse[i];
      }
    }
}

