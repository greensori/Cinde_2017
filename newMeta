//controlling 3 stepping motor controller
//must setting new (int totalswitch)
//char totalswitch = a ~ c (1 stepping) d, e, f(1-2), (2-3), (1-3) g(1-2-3)
//stepset() -> setting pulse -> end
//before stepping operateion ending, must send serial signals
//step = pulse * 2


#define pulseTimer 2000
#define limitrpm 870
#define sumStep 3

const int ENA[sumStep] = {5, 8, 11};
const int DIR[sumStep] = {6, 9, 12};
const int STEP[sumStep] = {7, 10, 13};

//stepping control guide
//setting int the charconverter not changed
int stepPulse[sumStep] = {1000, 1000, 1000};
//manually settign the amount of pulse count(maybe do not using anymore
int stepCount[sumStep];
//accelation value of stepping motor
int stepAccel[sumStep] = {0, 0, 0};
int accelLimit[sumStep] = {570, 570, 570};
//if this value wil be > 0 then working before charconverter
int remainPulse[sumStep];
//this two values have total/seperate stepping structure
int equalPulse[sumStep];
int worker[sumStep];
// reading from python
char ch;
// using temporaly like for
int count;
int i;
//stepping number, using in charconverter
int stepno;
//how many stepping works, set in the charconverter
//worker will be setting 0 in stepmov
//terminalStep storage remain pulse  timer
//if (terminalStep < 0) then there is no working
int terminalStep;
//saving remain pulse
int steploop[2];
//setting 3stepping motors (steps, pulse, maxpulse, acc)
//using in dvacalculator

//int result;
//int dvapulse;
//saves remain stepping pulse [stepno, pulse]
//int delaystep[2];
//
//int steptimer;

//using nuMeta
int maxPulse[2];
int minPulse[2];

//level switch this contrl while process
int proclv;


void setup() {
    Serial.begin(115200);
    for (i= 0; i < 3; i++) {
       pinMode(ENA[i], OUTPUT);
       digitalWrite(ENA[i], HIGH);
       pinMode(DIR[i], OUTPUT);     
       pinMode(STEP[i], OUTPUT);
    }
}

//charconverter. reang serial information from pc
//stepmov ->  dvastep() -> stepcal()
//if there is remain steps then working remain proc

void loop() {
  if (Serial.available() > 0) {
    ch = Serial.read();
    newStart();
    terminalStep = pulseTimer;
    charconverter();
    Switch (proclv):
        case 1:
            //initiating phase
            break;
        case 2:
            //idle phase
            break;
        case 3:
            //terminal phase
            break;
    if (worker >= 0) {
      steptimer = pulseTimer;
    }
  }
}

//initiating values
void newStart() {
  for (i = 0; i < sumStep; i++) {
    equalPulse[i] = 0;
    worker[i] = 0;
  }
}


// # $ % = initiate setting stepping
// 0~7 accelation setting
// 89 setting dirextion
void charconverter() {
    if (35 <= ch && ch <= 37) {
      switch (ch) {
        case 35:
          stepno = 0;
          Serial.println ("setting stepping 1");
          break;
        case 36:
          stepno = 1;
          Serial.println ("setting stepping 2");   
          break;
        case 37:
          stepno = 2;
          Serial.println ("setting stepping 3");          
          break;
      }
    } else if (48<= ch && ch <= 57) {
      Serial.print ("setiing accelaration");
      switch (ch) {
        case 48:
          stepAccel[stepno] = 0;
          break;
        case 49:
          stepAccel[stepno] = 1;
          break;
        case 50:
          stepAccel[stepno] = 2;
          break;
        case 51:
          stepAccel[stepno] = 3;
          break;
        case 52:
          stepAccel[stepno] = -1;
          break;
        case 53:
          stepAccel[stepno] = -2;
          break;
        case 54:
          stepAccel[stepno] = -3;
          break;
        case 55:
          stepAccel[stepno] = (stepAccel[stepno] * 2);
          break;
        case 56:
          digitalWrite(DIR[stepno], HIGH);
          break;
        case 57:
          digitalWrite(DIR[stepno], LOW);
          break;
      } //end switch
    } else if (97<= ch && ch <= 122) {
      Serial.println ("setting pulse");
    switch (ch) {
      case 97:
        stepPulse[stepno] = 800;
        remainPulse[stepno] = 800;
        break;
      case 98:
        stepPulse[stepno] = 1000;
        remainPulse[stepno] = 1000;
        break;
      case 99:
        stepPulse[stepno] = 2000;
        remainPulse[stepno] = 2000;
        break;
      default:
        break;            
     } //end switch
    } else if (65 <= ch && ch <= 90) {
      Serial.println ("which wtepping will be on");
      switch (ch) {
        case 65:
          activestep(1);
          break;
        case 66:
          activestep(2);
          break;
        case 67:
          activestep(3);
          break;
        default:
          break;
      } // switch end
  } //end if


} // end proc

//to getting a active state stepping
//end of stepmov worker will be initiating
void activestep(int a) {
  worker[0] += 1;
  if (worker[0] < sumStep) {
    for (i = 1; i < sumStep; i++) {
      if (worker[i] < 0) {
        worker[i] = a;
        i = sumStep;
      }
    }
  } //end if
} //end proc

void accelset() {
    if (stepPulse[stepno] >= accelLimit[stepno]) {
        stepPulse[stepno] = stepPulse[stepno] - stepAccel[stepno];
    } else {
        stepPulse[stepno] = accelLimit[stepno];
    } // if end
} //proc end

void nuMetamov() {
  while (terminalStep > 0 ) {
    
  }
}


void temp1() {
  for (i = 1; i < sumStep; i++) {
    if (worker[i] != 0) {
      count = worker[i];
      digitalWrite(STEP[count], HIGH);
    }
  }
  delayMicroseconds (minPulse[1]);
}

void nuMeta() {
  //when 3 stepper working
  if (worker[0] == sumStep) {
    for (i = 0; i < sumStep; i++) {
      digitalWrite(ENA[i], LOW);
    }
  } else if (worker[0] > 0) {
    //savings the amount of active stepper
    for (i = 1; i < sumStep; i++) {
      count = worker[i];
      if (minPulse[0] > stepPulse[count]) {
        minPulse[0] = stepPulse[count];
        minPulse[1] = count;
        equalPulse[0] = count;
        for (i = 1; i < sumStep; i++) {
          equalPulse[i] = 0;
        }
        } else if (minPulse[0] = stepPulse[count]) {
          equalPulse[0] += 1;
          if (equalPulse[0] < sumStep) {
            for (i = 1; i < sumStep; i++) {
              if (equalPulse[i] != 0) {
                equalPulse[i] = count;
                i = sumStep;
              }
            }
        } // if end
      } // for end    
    }// if end
  } // proc end
}


//
    digitalWrite(ENA[minPulse[1]], HIGH):
    delaymicroseconds(minPulse[0]);
    digitalWrite(ENA[minPuklse[1], LOW);

for (i = 0; i < sumStep; i++) {
    remainPulse[i] -= minPulse[0]
    if (remainPulse[i] <= 0) {
      remainPulse[i] = stepPulse[i];
      }
}

// if (equalPulse[0] == sumStep) {
    for (i = 0; i < sumStep; i++) {
        digitalWrite((ENA[i], HIGH);
    }
    delayMicroseconds(minPulse[0]);
    for (i = 0; i < sumStep; i++) {
        digitalWrite((ENA[i], LOW);
    } else if (equalPuse > 1 && equalPulse[0] < sumStep) {
    for (i = 1; i < sumStep; i++) {
        if (equalPulse[i] > 0 ){
            digitalWrite(ENA[i], HIGH);
          }
    }
}
